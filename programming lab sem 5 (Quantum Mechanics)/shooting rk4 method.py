
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd 
from scipy import stats


def rk4(ini_cond,inde_f,func,N):
    h = (inde_f - ini_cond[0])/(N)       
    time_vect = np.array([ini_cond[0]])
    a = []
    for i in range(1,len(ini_cond)):
        a.append(ini_cond[i])
    y_vect = np.array(a).reshape(len(ini_cond)-1,1)
    
    for i in range(N):
        m1_vect = h*func(time_vect[i],y_vect[:,i])
        m2_vect = h*func(time_vect[i] + (h/2),y_vect[:,i] + (m1_vect/2))
        m3_vect = h*func(time_vect[i] + (h/2),y_vect[:,i] + (m2_vect/2))
        m4_vect = h*func(time_vect[i] + h,y_vect[:,i]+m3_vect)
        mrk4 = (1/6)*(m1_vect + 2*m2_vect + 2*m3_vect + m4_vect)
        t = time_vect[i] + h
        t_vect = np.append(time_vect,t)
        time_vect = t_vect
        y_next = y_vect[:,i] + mrk4
        Y = []
        for j in range(len(y_vect)):
            y = np.append(y_vect[j],y_next[j])
            Y.append(y)
        y_vect = np.array(Y)
    return [time_vect,y_vect]


def func(x,dep):
    y,z=dep
    f1=z
    f2=np.sin(3*x) - y
    
    return np.array([f1,f2])

def linearinterp(y0,y1,P0,P1):
    y2 = y1 - ((y1-y0)/(P1-P0))*P1
    return y2

def Lin_shooting(f,a,b,N,z0,zf):

    IC_1=np.array([0,-1-z0,z0])
    A1=rk4(IC_1,b,f,N)
    y1,z1=A1[1][0],A1[1][1]

    IC_2=np.array([0,-1-zf,zf])
    A2=rk4(IC_2,b,f,N)
    y2,z2=A2[1][0],A2[1][1]

    yb_der=1           #given boundary condition for y'(pi/2)=1
    
    P0=1-z1[-1]    #comparing the boundary values with the values generated by RK4 for initial guess condition.
    P1=1-z2[-1]
    l1=[];l2=[];l3=[]
    
            
            
    new_guess=linearinterp(z0,zf,P0,P1)   #approximate z(0) 

    
    zf=new_guess
    IC_3=np.array([0,-1-zf,zf])
            
    A3=rk4(IC_3,b,f,N)
    l1,l2=A3[1][0],A3[1][1]
    l3=A3[0]

    z_new=yb_der - l2[-1]
    P0=P1
    P1=z_new

    return l1,l2,l3

